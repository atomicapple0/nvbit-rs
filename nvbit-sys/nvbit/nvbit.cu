/*
 *
 * IMPORTANT: This needs to be a .cu!
 * e.g. nvbit_tool.h header uses CUDA superset to launch kernel
 *
 */

#include "nvbit-sys/nvbit/nvbit.h"

/* #include "nvbit-sys/nvbit/channel.h" */

// #include "nvbit-sys/nvbit_release/core/utils/channel.hpp"

/* // we forgot this for a long time */
/* // this file is generated by cxx */
/* #include "nvbit-sys/src/lib.rs.h" */

// provides the API for instrumentation
// NOTE: THIS MUST BE INCLUDED BEFORE CUDA (cuda not needed)
// it sets
/* #define __CUDA_API_VERSION_INTERNAL */
/* #include "cuda.h" */
// which is required by cuda.h
/* #include "nvbit-sys/nvbit_release/core/nvbit.h" */

// provided cuda api
/* #include "nvbit-sys/nvbit_release/core/cuda.h" */
/* #include <cuda_runtime_api.h> */
/* #include <cuda.h> */

// every nvbit tool must include this once to initialize tracing
// #include "nvbit-sys/nvbit_release/core/nvbit_tool.h"
/* #include "nvbit_tool.h" */

std::unique_ptr<std::vector<CUfunctionShim>> rust_nvbit_get_related_functions(
    CUcontext ctx, CUfunction func
) {
  std::vector<CUfunction> related = nvbit_get_related_functions(ctx, func);
  auto vec = std::unique_ptr<std::vector<CUfunctionShim>>(new std::vector<CUfunctionShim>());
  for (auto & element : related) {
    vec->push_back(CUfunctionShim { element });
  }

  return vec;
}

std::unique_ptr<std::vector<InstrShim>> rust_nvbit_get_instrs(
    CUcontext ctx, CUfunction func
) {
  std::vector<Instr*> instructions = nvbit_get_instrs(ctx, func);
  auto vec = std::unique_ptr<std::vector<InstrShim>>(new std::vector<InstrShim>());
  for (auto & instr : instructions ) {
    vec->push_back(InstrShim { instr });
  }
  return vec;
}
